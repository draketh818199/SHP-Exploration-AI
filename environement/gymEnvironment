import gymnasium as gym
from gymnasium import spaces
import numpy as np
import copy
import math


class GridVisionEnv(gym.Env):

    metadata = {"render_modes": ["human"]}

    def __init__(self, map_layout=None, vision_radius=3, render_mode=None):
        super().__init__()

        self.original_map = map_layout
        self.vision_radius = vision_radius
        self.render_mode = render_mode

        self.size = len(map_layout)

        # Actions: up, down, left, right
        self.action_space = spaces.Discrete(4)

        if (map_layout == None):
            from environmentControl import MAP0
            map_layout = MAP0

        # Observation: visible square around player
        view_size = 2 * vision_radius + 1
        self.observation_space = spaces.Box(
            low=-1,
            high=3,
            shape=(view_size, view_size),
            dtype=np.int8
        )

        self._reset_internal_state()

    def _reset_internal_state(self):
        self.grid = copy.deepcopy(self.original_map)
        self.player_pos = self._find_player_start()
        self.grid[self.player_pos[0]][self.player_pos[1]] = " P "
        self.terminated = False

    def _find_player_start(self):
        for r in range(len(self.grid)):
            for c in range(len(self.grid[r])):
                if self.grid[r][c] == " O ":
                    self.grid[r][c] = "   "
                    return (r, c)
        raise ValueError("No player start marker found")

    def reset(self, seed=None, options=None):
        super().reset(seed=seed)
        self._reset_internal_state()
        obs = self._get_observation()
        return obs, {}

    def step(self, action):

        if self.terminated:
            raise RuntimeError("Step called after episode termination")

        move_map = {
            0: (-1, 0),  # up
            1: (1, 0),   # down
            2: (0, -1),  # left
            3: (0, 1),   # right
        }

        dx, dy = move_map[action]
        x, y = self.player_pos
        nx, ny = x + dx, y + dy

        reward = -0.01  # small step penalty

        # bounds check
        if 0 <= nx < self.size and 0 <= ny < self.size:

            if self.grid[nx][ny] != "███":  # not wall

                if self.grid[nx][ny] == " G ":
                    reward = 1.0
                    self.terminated = True

                self.grid[x][y] = "   "
                self.grid[nx][ny] = " P "
                self.player_pos = (nx, ny)

        obs = self._get_observation()
        return obs, reward, self.terminated, False, {}

    def _encode_tile(self, tile):
        if tile == "███":
            return 1
        if tile == " G ":
            return 2
        if tile == " P ":
            return 3
        if tile == "   ":
            return 0
        return -1

    def _get_observation(self):
        px, py = self.player_pos
        radius = self.vision_radius

        view_size = 2 * radius + 1
        obs = np.full((view_size, view_size), -1, dtype=np.int8)

        for i, r in enumerate(range(px - radius, px + radius + 1)):
            for j, c in enumerate(range(py - radius, py + radius + 1)):

                dist = math.sqrt((r - px)**2 + (c - py)**2)
                if dist > radius:
                    continue

                if 0 <= r < self.size and 0 <= c < self.size:
                    obs[i, j] = self._encode_tile(self.grid[r][c])

        return obs

    def render(self):
        if self.render_mode == "human":
            for row in self.grid:
                print("".join(row))
            print()
